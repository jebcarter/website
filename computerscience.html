<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>Jeb Carter - Computer Science</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
  </head>
  <body>
    <div class="code-image">
      <div class="pagetitle">
        <h1 class="bubbletext">C O M P U T E R <br> S C I E N C E</h1>
      </div>
    </div>
    <div class="sticky">
      <button onclick="document.location = 'index.html'" class="buttonpagelinks"
      style="vertical-align:middle"><span>Home </span></button>
      <button onclick="document.location = 'engineering.html'" class="buttonpagelinks"
      style="vertical-align:middle"><span>Engineering </span></button>
      <button onclick="document.location = 'computerscience.html'" class="buttonpagelinks"
      style="vertical-align:middle"><span>Computer Science </span></button>
      <button onclick="document.location = 'music.html'" class="buttonpagelinks"
      style="vertical-align:middle"><span>Music  </span></button>
    </div>
    <div class="main1">
      <h2>Computer Science Experience</h2>
      <p class="bodytext">
        During my first two years at Princeton, I have established extensive experience programming in
        Java and C. I have worked on numerous start-to-finish projects in both languages.
        Some of these projects included implementing a full Unix Shell, implementing heap manager
        modules for system memory management, implementing Burrows-Wheeler data compression,
        and writing code in assembly language, just to name a few. I've worked on
        several projects using AutoCAD and Fusion 360 3D-Modeling software and I am
        also very comfortable working with HTML, CSS, RStudio, MATLAB, Wolfram Mathematica,
        Microsoft Office, and Photoshop.
        <br>
      </p>
      <p class="bodytext">
        Below, I have highlighted some of my more notable/interesting computer science projects to date.
        Those detailed on this page include:
        <ul>
          <li><a href="#KnightTour">The Knight's Tour</a></li>
          <li><a href="#KnightTrap">The Knight Trapping Problem</a></li>
          <li><a href="#8Puzzle">The Slider Puzzle Solver</a></li>
          <li><a href="#Recursive">Recursive Artwork</a></li>
          <li><a href="#NBody">The NBody Problem</a></li>
          <li><a href="#Balls">Bouncing Balls</a></li>
        </ul>
      </p>
    </div>

<!---------------------------------------------------------------------------->
<!--                          Knight Tour                                    ->
<!---------------------------------------------------------------------------->

    <div class="main2">
      <h3 id="KnightTour">The Knight's Tour</h3>
      <p class="bodytext">
        The Knight's Tour is a famous, centuries-old chess puzzle which asks one question:
        How can a Knight (from the game of chess) navigate a chess board such that it visits every square
        exactly once? I love the game of chess so, naturally, when I learned about this
        puzzle, I became determined to solve it myself.
      </p>
      <figure class="rightmedium">
        <img src="/images-videos/Knight_Tour/Knight_Tour-8-0-0.gif" width="300" height="300"
        alt="8x8 Knight's Tour">
        <figcaption>8x8 Knight's Tour</figcaption>
      </figure>
      <p class="bodytext">
        The problem seems, on the surface, incredibly daunting. My first strategy was to
        use a Mimimum Priority Queue, assigning a 'score' to every board based on the position
        of the knight and the locations of remaining squares. (This is the technique I used
        to solve Sliding Puzzles, and it is described in greater detail in that section.) However, this solution
        only succeeded in finding valid knight's tours for boards 5x5 and smaller; anything
        larger would exceed the computer's memory capacity or take too long. This is
        because such a strategy requires that the program store all possible previous boards for
        later retrieval, something that isn't feasible once the paths get very long.
      </p>
      <p class="bodytext">
        I realized that, to solve the problem for larger boards, I needed to develop a heuristic
        that would inform the decision of the knight at each move, but not require it to
        consider all possible paths. Choosing this heuristic was incredibly important, as it
        would determine the success of the program. After quite a bit of trial and error,
        I settled on the final, and ultimately successful, heuristic: When choosing the next square
        for the knight, choose the square which will give the knight the fewest available
        moves. Logically, this heuristic makes sense: it's in the knight's interest to keep
        its path compact and fill holes in otherwise visited space. This strategy minimizes
        the creation of 'islands' (unvisited squares to which there are no valid routes)
        because a square that is becoming isolated from other unvisited squares will be filled
        according to the heuristic.
      </p>
      <figure class="video">
        <video width="500" height="500" controls autoplay>
          <source src="/images-videos/Knight_Tour/Knight_Tour-15-10-12.mp4"
          type="video/mp4">
          Your browser does not support this video.
        </video>
        <figcaption>15x15 Knight's Tour</figcaption>
      </figure>
      <p class="bodytext">
        Compared to my first attempt, the fewest-squares heuristic is superior by orders
        of magnitude. It minimizes the required memory and solves the puzzle in linear time.
        Additionally, by my calculations, the fewest-squares heuristic is successful
        in finding a knight's tour over <b>95%</b> of the time for all boards smaller than <b>80 x 80</b>
        with the knight in <b>any</b> position. Once the size of the boards reaches the hundreds, the success
        rate drops to around 50% and continues to fall as the sizes increase.
      </p>
    </div>

<!---------------------------------------------------------------------------->
<!--                          Knight Trap                                    ->
<!---------------------------------------------------------------------------->

    <div class="main1">
      <h3 id="KnightTrap">The Knight Trapping Problem</h3>
      <figure class="rightlarge">
        <img src="/images-videos/Knight_Trap/Knight_Trap_Number_Label.jpg" width="400" height="400"
        alt="Spiral Labeling">
        <figcaption>Spiral Labeling of Board</figcaption>
      </figure>
      <p class="bodytext">
        This project is inspired by
        <a href="https://www.youtube.com/channel/UCoxcjq-8xIDTYp3uz647V5A" title="Go to Numberphile Channel"
        target="_blank">Numberphile's</a>
        YouTube video entitled
        <a href="https://www.youtube.com/watch?v=RGQe8waGJ4w&t=62s" title="Go to Video"
        target="_blank">"The Trapped Knight"</a>.
      </p>
      <p class="bodytext">
        The Knight Trapping Algorithm computes a unique, infinite sequence of numbers given by
        the following problem:
      </p>
      <p class="bodytext">
        The Knight Trapping Problem is another fascinating problem involving the
        mechanics of a knight on a chess board. In this scenario, a knight is
        placed on an infinitely large chess board. The squares on this board are labeled in
        a very particular way. As shown in the diagram (right), the center
        square is given the value (1), then the values increase in a spiral shape infinitely
        outward. Initially, the knight is placed at square (1).
      </p>
      <figure class="leftlarge">
        <img src="/images-videos/Knight_Trap/Knight_Trap-1.gif" width="400" height="400"
        alt="First Trapping Square gif">
        <figcaption>Discovery of the First Trapping Square</figcaption>
      </figure>
      <p class="bodytext">
        The knight (moves like a knight from chess) begins at the central square (1)
        and can move to any legal square (making an "L" shape). For example, a
        knight at (1) could move to (10), (12), (14), (16), (18), (20), (22), or (24). The knight has
        two movement constraints: It cannot visit a square it has already been to,
        and it will always jump to the square with the smallest value. Once there,
        the knight will again compare the squares' values of all legal moves, with
        the exception of square (1), which it has already visited.
      </p>
      <p class="bodytext">
        This process continues until, at some point, the knight becomes 'trapped'.
        In this situation, the knight has already visited all 8 of the potential squares that
        it could legally jump to. A square where the knight becomes trapped is called
        a "trapping square." The first time the knight reaches one of these trapping squarres
        is at square (2084). An animation of the knight discovering the first trapping square
        is shown (right). Once the knight reaches any 'trapping square,' the algorithm resets,
        returns the knight to square (1), and <u>marks all previously visited trapping squares
        as "already visited."</u> Because the trapping square is marked as "already visited",
        the knight will not visit that square and hence will not become trapped
        at that particular square on the next trial. Instead, the knight bypasses
        all previously discovered trapping squares and gets trapped at the next one.
        <br><br><br>
      </p>
      <figure class="video">
        <video width="500" height="500" controls autoplay>
          <source src="/images-videos/Knight_Trap/Knight_Trap-8.mp4"
          type="video/mp4">
          Your browser does not support this video.
        </video>
        <figcaption>Discovery of the First 8 Trapping Squares</figcaption>
      </figure>
      <p class="bodytext">
        By repeating trials of increasing size, the algorithm produces a series of integers,
        which are the values associated with the trapping squares in each successive
        trial. I have run my knight trapping algorithm for the first 4000 trapping squares.
        Within the first 4000, the farthest trapping square discovered has a staggering value
        of (10,486,083). A complete list of the first 4000 trapping square values can be found
        <a href="trappingsquares.html">here</a>. Plotting the value of the trapping
        squares against the order in which they are discovered yields the following
        plot:
      </p>
      <figure class="middlewide">
        <img src="/images-videos/Knight_Trap/Trapping_Squares_Graph.png" width="700" height="370"
        alt="Trapping Squares Graph">
        <figcaption>Graph of Trapping Values vs Order of Discovery</figcaption>
      </figure>
      <p class="bodytext">
        Interestingly, the values of the trapping squares seem to increase linearly
        as the knight explores farther from the center. Though a linear relationship
        is not all that surprising, it is by no means a given! The size of the spirals
        increases as the square of the radius, by virtue of the nature of the puzzle, and
        there isn't any clear, logical intuition suggesting that the relationship would
        be linear, so the fact that it is linear is incredibly interesting! (I actually
        would have guessed that it'd be logarithmic.) Another interesting observation
        is that the trapping squares remain relatively dense even at very large values.
        If this pattern does, in fact, continue indefinitely, then one would expect this
        series of values to be an <b>infinite</b> series. Although it's rather predicable
        that the number of trapping squares is (probably) infinite, it isn't necessarily
        guaranteed. It's technically possible that there is a finite number of trapping
        squares, but I find it incredibly unlikely, especially given the data above. Perhaps
        a mathematician with expertise in proofs and map theory could prove my conjecture
        that the series is infinite, but I'm afraid that's a bit above my pay grade!
      </p>
    </div>

<!---------------------------------------------------------------------------->
<!--                          Sliding Puzzle                                 ->
<!---------------------------------------------------------------------------->

    <div class="main2">
      <h3 id="8Puzzle">The Sliding Puzzle Solver</h3>
      <p class="bodytext">
        I built this project as part of the course COS 226, <i>Algorithms and Data
        Structures</i>, at Princeton University.
      </p>
      <figure class="rightsmall">
        <img src="/images-videos/Sliding_Puzzle/Sliding_Puzzle_2x2-06.gif" width="200" height="200"
        alt="2x2 Sliding Puzzle">
        <figcaption>2x2 Sliding Puzzle</figcaption>
      </figure>
      <p class="bodytext">
        The Sliding Puzzle is one of the most popular handheld puzzles
        in circulation. The task is simple: You are given a grid of squares, all
        filled in with the exception of one empty slot. These squares can slide past one
        another, and it is your job to put them in order from left to right and top
        to bottom, using only the one empty slot to move the squares around. A very simple
        example of a small 2x2 sliding puzzle is shown (right). Given enough
        time and moves, most people can solve a sliding puzzle, though they may struggle
        with larger ones. Nevertheless, my algorithm is designed to find the solution
        to any puzzle up to 5x5 in size in the shortest possible number of moves.
        <br>
      </p>
      <figure class="leftmedium">
        <img src="/images-videos/Sliding_Puzzle/Sliding_Puzzle_3x3-31.gif" width="300" height="300"
        alt="3x3 Sliding Puzzle">
        <figcaption>3x3 Sliding Puzzle</figcaption>
      </figure>
      <p class="bodytext">
        In order to find the solution to slider puzzles, I used the
        <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A* Search Algorithm</a>
        with a Minimum Priority Queue. I defined a "search node" as a board, the number of moves
        made to reach it, and a reference to the previous node. Additionally, every board
        is assigned a "priority function," or a value that describes how worthwhile
        that board is to explore. The priority function I chose, known widely as the
        "Manhattan Priority Function," is given by the number of moves made to reach
        that board plus the "Manhattan Distance" of that board, where the Manhattan Distance is
        the sum of the vertical and horizontal distances from each tile to its
        solved location. This priority function gives lower values to boards which were
        reached in fewer moves and boards that are closer to the solution. Additionally, the Manhattan
        function of any board is always greater than or equal to the shortest possible number
        of steps needed to solve it from start to finish.
      </p>
      <figure class="rightlarge">
        <img src="/images-videos/Sliding_Puzzle/Sliding_Puzzle_34.gif" width="400" height="400"
        alt="4x4 Sliding Puzzle">
        <figcaption>4x4 Sliding Puzzle</figcaption>
      </figure>
      <p class="bodytext">
        As given by the A* Search Algorithm, the board with the lowest priority value is removed
        from the queue, the priority functions of all of its "children" (boards that can be
        reached in one move) are calculated, and the children are added back into to the queue.
        Once a board is removed from the queue which is equal to the final solution,
        you are guaranteed that you have found the shortest possible solution. This is because
        of the nature of the Manhattan Priority Function. At the moment it is removed from
        the queue, the solved board has the smallest priority function of all
        existing boards. Because all Manhattan Functions are greater than or equal to
        the solving distance, and because all <b>remaining</b> Manhattan Functions are larger
        than the solution just discovered, the found solution must be the quickest one.
        <br><br><br>
      </p>
      <figure class="middlelarge">
        <img src="/images-videos/Sliding_Puzzle/Sliding_Puzzle_44.gif" width="500" height="500"
        alt="5x5 Sliding Puzzle">
        <figcaption>5x5 Sliding Puzzle</figcaption>
      </figure>
    </div>

<!---------------------------------------------------------------------------->
<!--                          Recursive Artwork                              ->
<!---------------------------------------------------------------------------->

    <div class="main1">
      <h3 id="Recursive">Recursive Artwork</h3>
      <p class="bodytext">
        I built this project as part of the course COS 126, <i>Computer Science: An
        Interdisciplinary Approach</i>, at Princeton University.
      </p>
      <figure class="rightsmall">
        <img src="/images-videos/Recursion/Sierpinski.png" width="200" height="200"
        alt="Sierpinski's Triangle">
        <figcaption>Sierpinski's Triangle</figcaption>
      </figure>
      <p class="bodytext">
        This project was an experiment in using computation and geometry to create
        fractals digitally. The inspiration for all of the fractal artwork contained
        herein was the Sierpinski Triangle (right). This famous fractal, named after
        mathematician and number theorist Waclaw Sierpinski, consists of one large
        equilateral triangle containing three smaller equilateral triangles, each containing
        three triangles of their own, and so on. This 'multiplicative' property of Sierpinski's
        Triangle is what makes recursive functions such a useful tool for creating art
        similar to Sierpinski's.
      </p>
      <p class="bodytext">
        To create fractal artwork inspired by Sierpinski's Triangle, I used recursive
        functions in Java in conjuction with Princeton standard libraries (for drawing).
        The general structure of the algorithm is this: call a function that draws
        a particular shape or icon. However, before that function returns, have it
        recursively call <i>itself</i> multiple times with new position and size parameters
        for the drawing. Repeat this layered recursion 5-8 times (any more and the program
        starts to time out), each time drawing a smaller and smaller version of the
        same shape or icon in positions relative to their 'parent.' Depending on the
        choice of the initial shape and subsequent positioning of recursive children,
        a wide variety of fractals can form. Some of the more interesting and/or
        beautiful pieces that I created are shown below:
      </p>
      <div class="row">
        <div class="3column">
          <img src="/images-videos/Recursion/Recursion_Random_Spiral1.png" alt="Raindow Spiral 1" style="width:100%">
        </div>
        <div class="3column">
          <img src="/images-videos/Recursion/Recursion_Octagon.PNG" alt="Nested Octagon" style="width:100%">
        </div>
        <div class="3column">
          <img src="/images-videos/Recursion/Recursion_Random_Spiral2.PNG" alt="Raindow Spiral 2" style="width:100%">
        </div>
      </div>
      <div class="row">
        <div class="2column">
          <img src="/images-videos/Recursion/Recursion_Ghost.PNG" alt="Ghost Tree" style="width:100%">
        </div>
        <div class="2column">
          <video width=100% controls autoplay>
            <source src="/images-videos/Recursion/Recursion_Ghost.mp4"
            type="video/mp4">
            Your browser does not support this video.
          </video>
        </div>
      </div>
    </div>

<!---------------------------------------------------------------------------->
<!--                          NBody                                          ->
<!---------------------------------------------------------------------------->

    <div class="main2">
      <h3 id="NBody">The NBody Problem</h3>
      <p class="bodytext">
        Filler
      </p>
    </div>

<!---------------------------------------------------------------------------->
<!--                          Bouncing Balls                                 ->
<!---------------------------------------------------------------------------->

    <div class="main1">
      <h3 id="Balls">Bouncing Balls</h3>
      <p class="bodytext">
        Filler
      </p>
    </div>

    <p class="bottomtext">
      <br><br><br>
      _______________________________________________________
      <br><br>
      Created and coded in entirety by Jeb Carter
      <br>
      2020
      <br>
      _______________________________________________________
    </p>

  </body>
</html>

<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>Jeb Carter - Computer Science</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
  </head>
  <body>
    <div class="code-image">
      <div class="pagetitle">
        <h1 class="bubbletext">C O M P U T E R <br> S C I E N C E</h1>
      </div>
    </div>
    <div class="main1">
      <h2>Computer Science Experience</h2>
      <p class="bodytext">
        During my first two years at Princeton, I have established extensive experience programming in
        Java and C. I have worked on numerous start-to-finish projects in both languages.
        Some of these projects included implementing a full Unix Shell, implementing heap manager
        modules for system memory management, implementing Burrows-Wheeler data compression,
        and writing code in assembly language, just to name a few. I've worked on
        several projects using AutoCAD and Fusion 360 3D-Modeling software and I am
        also very comfortable working with HTML, CSS, RStudio, MATLAB, Wolfram Mathematica,
        Microsoft Office, and Photoshop.
        <br>
      </p>
      <p class="bodytext">
        Below, I have highlighted some of my more notable/interesting computer science projects to date.
        Those detailed on this page include:
        <ul>
          <li><a href="#KnightTour">The Knight's Tour</a></li>
          <li><a href="#KnightTrap">The Knight Trapping Problem</a></li>
          <li><a href="#8Puzzle">The 8-Puzzle Solver</a></li>
          <li><a href="#Recursive">Recursive Artwork</a></li>
          <li><a href="#NBody">The NBody Problem</a></li>
          <li><a href="#Balls">Bouncing Balls</a></li>
        </ul>
      </p>
    </div>


    <div class="main2">
      <h3 id="KnightTour">The Knight's Tour</h3>
      <p class="bodytext">
        The Knight's Tour is a famous, centuries-old chess puzzle which asks one question:
        How can a Knight (from the game of chess) navigate a chess board such that it visits every square
        exactly once? I love the game of chess so, naturally, when I learned about this
        puzzle, I became determined to solve it myself.
      </p>
      <figure class="rightmedium">
        <img src="/images-videos/Knight_Tour/Knight_Tour-8-0-0.gif" width="300" height="320"
        alt="8x8 Knight's Tour">
        <figcaption>8x8 Knight's Tour</figcaption>
      </figure>
      <p class="bodytext">
        The problem seems, on the surface, incredibly daunting. My first strategy was to
        use a Mimimum Priority Queue, assigning a 'score' to every board based on the position
        of the knight and the locations of remaining squares. However, this solution
        only succeeded in finding valid knight's tours for boards 5x5 and smaller; anything
        larger would exceed the computer's memory capacity or take too long. This is
        because such a strategy requires that the program store all possible previous boards for
        later retrieval, something that isn't feasible once the paths get very long.
      </p>
      <p class="bodytext">
        I realized that, to solve the problem for larger boards, I needed to develop a heuristic
        that would inform the decision of the knight at each move, but not require it to
        consider all possible paths. Choosing this heuristic was incredibly important, as it
        would determine the success of the program. After quite a bit of trial and error,
        I settled on the final, and ultimately successful, heuristic: When choosing the next square
        for the knight, choose the square which will give the knight the fewest available
        moves. Logically, this heuristic makes sense: it's in the knight's interest to keep
        its path compact and fill holes in otherwise visited space. This strategy minimizes
        the creation of 'islands' (unvisited squares to which there are no valid routes)
        because a square that is becoming isolated from other unvisited squares will be filled
        according to the heuristic.
      </p>
      <figure class="video">
        <video width="500" height="500" controls autoplay>
          <source src="/images-videos/Knight_Tour/Knight_Tour-15-10-12.mp4"
          type="video/mp4">
          Your browser does not support this video.
        </video>
        <figcaption>15x15 Knight's Tour</figcaption>
      </figure>
      <p class="bodytext">
        Compared to my first attempt, the fewest-squares heuristic is superior by orders
        of magnitude. It minimizes the required memory and solves the puzzle in linear time.
        Additionally, by my calculations, the fewest-squares heuristic is successful
        in finding a knight's tour over <b>95%</b> of the time for all boards smaller than <b>80 x 80</b>
        with the knight in <b>any</b> position. Once the size of the boards reaches the hundreds, the success
        rate drops to around 50% and continues to fall as the sizes increase.
      </p>
    </div>


    <div class="main1">
      <h3 id="KnightTrap">The Knight Trapping Problem</h3>
      <p class="bodytext">
        This algorithm is inspired by
        <a href="https://www.youtube.com/channel/UCoxcjq-8xIDTYp3uz647V5A" title="Go to Numberphile Channel"
        target="_blank">Numberphile's</a>
        YouTube video entitled
        <a href="https://www.youtube.com/watch?v=RGQe8waGJ4w&t=62s" title="Go to Video"
        target="_blank">"The Trapped Knight"</a>.
      </p>
      <figure class="rightlarge">
        <img src="/images-videos/Knight_Trap/Knight_Trap_Number_Label.jpg" width="400" height="400"
        alt="Spiral Labeling">
        <figcaption>Spiral Labeling of Board</figcaption>
      </figure>
      <p class="bodytext">
        The Knight Trapping Algorithm computes a unique, infinite sequence of numbers given by
        the following problem:
      </p>
      <p class="bodytext">
        The Knight Trapping Problem is another fascinating problem involving the
        mechanics of a knight on a chess board. In this scenario, a knight is
        placed on an infinitely large chess board. The squares on this board are labeled in
        a very particular way. As shown in the diagram (right), the center
        square is labeled #1, then the numbers increase in a spiral shape infinitely
        outward. Initially, the knight is placed at square 1.
      </p>
      <p class="bodytext">
        The knight (moves like a knight from chess) begins at the central square (#1)
        and can move to any legal square (making an "L" shape). For example, a
        knight at 1 could move to 10, 12, 14, 16, 18, 20, 22, or 24. The knight has
        two movement constraints: It cannot visit a square it has already been to,
        and it will always jump to the square with the smallest value. Once there,
        the knight will again compare the squares' values of all legal moves, with
        the exception of square #1, which it has already visited.
      </p>
      <figure class="rightlarge">
        <img src="/images-videos/Knight_Trap/Knight_Trap-1.gif" width="400" height="400"
        alt="First Trapping Square gif">
        <figcaption>Discovery of the First Trapping Square</figcaption>
      </figure>
      <p class="bodytext">
        This process continues until, at some point, the knight becomes 'trapped'.
        In this situation, the knight has already visited all 8 of the potential squares that
        it could legally jump to. A square where the knight becomes trapped is called
        a "trapping square." The first time the knight reaches one of these trapping squarres
        is at square 2084. An animation of the knight discovering the first trapping square
        is shown (right). Once the knight reaches any 'trapping square,' the algorithm resets,
        returns the knight to square 1, and <u>marks all previously visited trapping squares
        as "already visited."</u> Because the trapping square is marked as "already visited",
        the knight will not visit that square and hence will not become trapped
        at that particular square on the next trial. Instead, the knight bypasses
        all previously discovered trapping squares and gets trapped at the next one.
      </p>
      <figure class="video">
        <video width="500" height="500" controls autoplay>
          <source src="/images-videos/Knight_Trap/Knight_Trap-8.mp4"
          type="video/mp4">
          Your browser does not support this video.
        </video>
        <figcaption>Discovery of the First 8 Trapping Squares</figcaption>
      </figure>
      <p class="bodytext">
        By repeating trials of increasing size, the algorithm produces a series of integers,
        which are the numbers of the squares at which the knight is trapped in each successive
        trial. I have run my knight trapping algorithm for the first 4000 trapping squares.
        Within the first 4000, the farthest trapping square discovered has a staggering value
        of 10,486,083. A complete list of the first 4000 trapping squares can be found
        <a href="trappingsquares.html">here</a>.
      </p>
    </div>




    <div class="main2">
      <h3 id="8Puzzle">The 8-Puzzle Solver</h3>
      <p class="bodytext">
        Filler
      </p>
    </div>
    <div class="main1">
      <h3 id="Recursive">Making Recursive Artwork</h3>
      <p class="bodytext">
        Filler
      </p>
    </div>
    <div class="main2">
      <h3 id="NBody">The NBody Problem</h3>
      <p class="bodytext">
        Filler
      </p>
    </div>
    <div class="main1">
      <h3 id="Balls">Bouncing Balls</h3>
      <p class="bodytext">
        Filler
      </p>
    </div>

    <p class="bottomtext">
      <br><br><br>
      _______________________________________________________
      <br><br>
      Created and coded in entirety by Jeb Carter
      <br>
      2020
      <br>
      _______________________________________________________
    </p>

  </body>
</html>
